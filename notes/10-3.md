save point: 10.3.5
https://courses.bootcampspot.com/courses/951/pages/10-dot-3-5-test-and-build-the-base-enemy-constructor?module_item_id=332665

# 10.3

## 10.3.1 Introduction

-   Working through "Create a Player Object" Issue on GitHub
-   Complete `Enemy` issue because similar to `Player`

Goals:

1. Write Jest tests that fake data updates to check multiple conditions
2. Use built-in Array prototype methods

## 10.3.2 Preview

<table>
    <tr>
        <th>Step</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Test and build <code>Player</code>'s health methods</td>
        <td>includes <code>getHealth()</code>, <code>removeHealth()</code>, and <code>isAlive()</code></td>
    </tr>
    <tr>
        <td>Test and build <code>Player</code>'s attach and potion methods</td>
        <td><code>Player</code>'s attack and potion methods rely on its health methods</td>
    </tr>
    <tr>
        <td>Test and build base <code>Enemy()</code> constructor</td>
        <td>This order for a reason</td>
    </tr>
    <tr>
        <td>Test and build <code>Enemy</code>'s methods</td>
        <td>copy them from <code>Player()</code></td>
    </tr>
</table>

## 10.3.3 Test and Build Player's Health Methods

Add methods to `Player()`

### Starting with `getHealth()` Method

-   creating the method in `Player` declutters. When we create `Game`, it only displays the game's data.
-   `expect.stringContaining()` is an expect method we can use to make sure our string includes our player's health.

```
test("gets player's health value", () => {
  const player = new Player('Dave');

  expect(player.getHealth()).toEqual(expect.stringContaining(player.health.toString()));
});
```

-   run test knowing it fails
-   using `expect.stringContaining()` in order to make sure string includes player health. It's also unspecific enough to allow flexibility if/when we change how it's displayed.

add `getHealth()` method to `Player.js` prototype:

```
Player.prototype.getHealth = function() {
  return `${this.name}'s health is now ${this.health}!`;
};
```

-   make sure test passes

-   check if player is alive:
-   Remember, truthy values are values that will be coerced to true in Boolean contexts, such as inside if statements.

```
test('checks if player is alive or not', () => {
  const player = new Player('Dave');

  expect(player.isAlive()).toBeTruthy();

  player.health = 0;

  expect(player.isAlive()).toBeFalsy();
});
```

-   add `isalive` method:

```
Player.prototype.isAlive = function() {
  if (this.health === 0) {
    return false;
  }
  return true;
};
```

-   write another test to handle `reduceHealth()`

```
test("subtracts from player's health", () => {
  const player = new Player('Dave');
  const oldHealth = player.health;

  player.reduceHealth(5);

  expect(player.health).toBe(oldHealth - 5);

  player.reduceHealth(99999);

  expect(player.health).toBe(0);
});
```

N.B.: **Create a new instance of the object being tested in every test.**

-   to start fresh,
-   test in isolation,
-   avoid unintended consequences.

add `reduceHealth()` method:

```
Player.prototype.reduceHealth = function(health) {
  this.health -= health;

  if (this.health < 0) {
    this.health = 0;
  }
};
```

## 10.3.4 Test and BuildPlayer's Attack and Potion Methods

To Dos:

-   get attack value of our player
-   add potions to their inventory
-   consume potions

### Write tests and method to get a player's attack value

??? I don't understand the max/min math formula here

```
Player.prototype.getAttackValue = function() {
  const min = this.strength - 5;
  const max = this.strength + 5;

  return Math.floor(Math.random() * (max - min) + min);
};
```

## 10.3.5 Test and Build the Base Enemy Constructor

Setup:

1. Create new branch for `Enemy()` constructor.
2. create new `Enemy.test.js` in `__tests__`
3. import and mcok the necessary modules to create a failing test
    1. check for proper project creation
    2. include `expect` for
        1. `Enemy` name,
        2. weapon, and
        3. potion.
4. **ALWAYS** MAKE SURE TEST FAILS BEFORE WRITING THE CORRESPONDING METHOD. IF IT PASSES, THEN GUARDRAILS ARE OFF.

```
const Enemy = require('../lib/Enemy.js');
const Potion = require('../lib/Potion.js');

jest.mock('../lib/Potion.js');

test('creates an enemy object', () => {
  const enemy = new Enemy('goblin', 'sword');

  expect(enemy.name).toBe('goblin');
  expect(enemy.weapon).toBe('sword');
  expect(enemy.health).toEqual(expect.any(Number));
  expect(enemy.strength).toEqual(expect.any(Number));
  expect(enemy.agility).toEqual(expect.any(Number));
  expect(enemy.potion).toEqual(expect.any(Object));
});
```

### Create Enemy Constructor

```
const Potion = require("./Potion");

function Enemy(name, weapon) {
	this.name = name;
	this.weapon = weapon;
	this.potion = new Potion();

	this.health = Math.floor(Math.random() * 10 + 85);
	this.strength = Math.floor(Math.random() * 5 + 5);
	this.agility = Math.floor(Math.random() * 5 + 5);
}

module.exports = Enemy;
```

## 10.3.6 Test and Build Enemy's Methods

### `Player()` --> `Enemy()` Tests

-   copy all health-related and attack-related tests from `Player.test.js` into `Enemy.test.js`.
-   rename `player` and `Player` to `enemy` and `Enemy`.
-   make sure every new instance of `Enemy` is initialized with a name and weapon

### `Player()` --> `Enemy()` Methods

-   Copy
    -   `isAlive()`
    -   `getHealth()`
    -   `getAttackValue()`
    -   `reduceHealth()`

### Create Weapon Method

first create test:

```
test('gets a description of the enemy', () => {
  const enemy = new Enemy('goblin', 'sword');

  expect(enemy.getDescription()).toEqual(expect.stringContaining('goblin'));
  expect(enemy.getDescription()).toEqual(expect.stringContaining('sword'));
});
```

Now fulfill the test:

```
Enemy.prototype.getDescription = function() {
  return `A ${this.name} holding a ${this.weapon} has appeared!`;
};
```
